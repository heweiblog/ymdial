/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef dialrpc_TYPES_H
#define dialrpc_TYPES_H

#include "thrift/Thrift.h"
#include "thrift/TApplicationException.h"
#include "thrift/protocol/TProtocol.h"
#include "thrift/transport/TTransport.h"



namespace rpc { namespace dial { namespace yamutech { namespace com {

struct ModuleType {
  enum type {
    DIALING = 2
  };
};

extern const std::map<int, const char*> _ModuleType_VALUES_TO_NAMES;

struct DialStatus {
  enum type {
    OK = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _DialStatus_VALUES_TO_NAMES;

struct RetCode {
  enum type {
    OK = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _RetCode_VALUES_TO_NAMES;

struct DialMethod {
  enum type {
    DIAL_TCPPORT = 0,
    DIAL_IMCP = 1,
    DIAL_HTTPGET = 2,
    DIAL_DATABASE = 3,
    DIAL_EXTHTTPGET = 4,
    DIAL_EXTTCPPORT = 5,
    DIAL_EXTHTTPPOST = 6,
    DIAL_HTTPCOMMON = 7,
    DIAL_UDPPORT = 8,
    DIAL_FTP = 9,
    DIAL_SMTP = 10,
    DIAL_SNMP = 11,
    DIAL_ORACLE = 12
  };
};

extern const std::map<int, const char*> _DialMethod_VALUES_TO_NAMES;

struct ModuleState {
  enum type {
    STARTUP = 0,
    REGISTERED = 1
  };
};

extern const std::map<int, const char*> _ModuleState_VALUES_TO_NAMES;

struct SysCommand {
  enum type {
    RestoreConfig = 0
  };
};

extern const std::map<int, const char*> _SysCommand_VALUES_TO_NAMES;

struct DialServerType {
  enum type {
    XPROXY = 0,
    REDIRECT = 1,
    XFORWARD = 2,
    DATACENTER = 3
  };
};

extern const std::map<int, const char*> _DialServerType_VALUES_TO_NAMES;

struct SnmpDevType {
  enum type {
    HOST = 0,
    ROUTER = 1,
    H3C = 2,
    HUAWEI = 3,
    CISCO = 4
  };
};

extern const std::map<int, const char*> _SnmpDevType_VALUES_TO_NAMES;

typedef std::string ObjectId;

typedef struct _Xception__isset {
  _Xception__isset() : errorCode(false), message(false) {}
  bool errorCode;
  bool message;
} _Xception__isset;

class Xception : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  Xception() : errorCode(0), message() {
  }

  virtual ~Xception() throw() {}

  int32_t errorCode;
  std::string message;

  _Xception__isset __isset;

  void __set_errorCode(const int32_t val) {
    errorCode = val;
  }

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const Xception & rhs) const
  {
    if (!(errorCode == rhs.errorCode))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const Xception &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Xception & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Xception &a, Xception &b);

typedef struct _HeartBeatState__isset {
  _HeartBeatState__isset() : mState(false), serverState(false) {}
  bool mState;
  bool serverState;
} _HeartBeatState__isset;

class HeartBeatState {
 public:

  static const char* ascii_fingerprint; // = "7D4563655A5F82FED16B1F5CE7672F0F";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x45,0x63,0x65,0x5A,0x5F,0x82,0xFE,0xD1,0x6B,0x1F,0x5C,0xE7,0x67,0x2F,0x0F};

  HeartBeatState() : mState((ModuleState::type)0), serverState(0) {
  }

  virtual ~HeartBeatState() throw() {}

  ModuleState::type mState;
  bool serverState;

  _HeartBeatState__isset __isset;

  void __set_mState(const ModuleState::type val) {
    mState = val;
  }

  void __set_serverState(const bool val) {
    serverState = val;
  }

  bool operator == (const HeartBeatState & rhs) const
  {
    if (!(mState == rhs.mState))
      return false;
    if (!(serverState == rhs.serverState))
      return false;
    return true;
  }
  bool operator != (const HeartBeatState &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartBeatState & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(HeartBeatState &a, HeartBeatState &b);

typedef struct _IpAddr__isset {
  _IpAddr__isset() : version(false), addr(false) {}
  bool version;
  bool addr;
} _IpAddr__isset;

class IpAddr {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  IpAddr() : version(0), addr() {
  }

  virtual ~IpAddr() throw() {}

  int32_t version;
  std::string addr;

  _IpAddr__isset __isset;

  void __set_version(const int32_t val) {
    version = val;
  }

  void __set_addr(const std::string& val) {
    addr = val;
  }

  bool operator == (const IpAddr & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (!(addr == rhs.addr))
      return false;
    return true;
  }
  bool operator != (const IpAddr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IpAddr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(IpAddr &a, IpAddr &b);

typedef struct _IpsecAddress__isset {
  _IpsecAddress__isset() : ip(false), mask(false) {}
  bool ip;
  bool mask;
} _IpsecAddress__isset;

class IpsecAddress {
 public:

  static const char* ascii_fingerprint; // = "9A8F93F25ADECFCB7475FE2B2CCBA45A";
  static const uint8_t binary_fingerprint[16]; // = {0x9A,0x8F,0x93,0xF2,0x5A,0xDE,0xCF,0xCB,0x74,0x75,0xFE,0x2B,0x2C,0xCB,0xA4,0x5A};

  IpsecAddress() : mask(0) {
  }

  virtual ~IpsecAddress() throw() {}

  IpAddr ip;
  int32_t mask;

  _IpsecAddress__isset __isset;

  void __set_ip(const IpAddr& val) {
    ip = val;
  }

  void __set_mask(const int32_t val) {
    mask = val;
  }

  bool operator == (const IpsecAddress & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(mask == rhs.mask))
      return false;
    return true;
  }
  bool operator != (const IpsecAddress &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IpsecAddress & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(IpsecAddress &a, IpsecAddress &b);

typedef struct _SysIpSec__isset {
  _SysIpSec__isset() : name(false), ipsec(false), recordId(false) {}
  bool name;
  bool ipsec;
  bool recordId;
} _SysIpSec__isset;

class SysIpSec {
 public:

  static const char* ascii_fingerprint; // = "06F2289C6439BB53A2F13AD977E2B0A0";
  static const uint8_t binary_fingerprint[16]; // = {0x06,0xF2,0x28,0x9C,0x64,0x39,0xBB,0x53,0xA2,0xF1,0x3A,0xD9,0x77,0xE2,0xB0,0xA0};

  SysIpSec() : name(), recordId() {
  }

  virtual ~SysIpSec() throw() {}

  std::string name;
  IpsecAddress ipsec;
  std::string recordId;

  _SysIpSec__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_ipsec(const IpsecAddress& val) {
    ipsec = val;
  }

  void __set_recordId(const std::string& val) {
    recordId = val;
  }

  bool operator == (const SysIpSec & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(ipsec == rhs.ipsec))
      return false;
    if (!(recordId == rhs.recordId))
      return false;
    return true;
  }
  bool operator != (const SysIpSec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SysIpSec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SysIpSec &a, SysIpSec &b);

typedef struct _DialOption__isset {
  _DialOption__isset() : destUrl(false), testMethod(false), expectCode(false), expectMatch(false), contentType(false), tag(false) {}
  bool destUrl;
  bool testMethod;
  bool expectCode;
  bool expectMatch;
  bool contentType;
  bool tag;
} _DialOption__isset;

class DialOption {
 public:

  static const char* ascii_fingerprint; // = "342D8159ED3852BA5ADC57C44E8B471C";
  static const uint8_t binary_fingerprint[16]; // = {0x34,0x2D,0x81,0x59,0xED,0x38,0x52,0xBA,0x5A,0xDC,0x57,0xC4,0x4E,0x8B,0x47,0x1C};

  DialOption() : destUrl(), testMethod(), expectMatch(), contentType(), tag(0) {
  }

  virtual ~DialOption() throw() {}

  std::string destUrl;
  std::string testMethod;
  std::vector<int32_t>  expectCode;
  std::string expectMatch;
  std::string contentType;
  int32_t tag;

  _DialOption__isset __isset;

  void __set_destUrl(const std::string& val) {
    destUrl = val;
  }

  void __set_testMethod(const std::string& val) {
    testMethod = val;
  }

  void __set_expectCode(const std::vector<int32_t> & val) {
    expectCode = val;
  }

  void __set_expectMatch(const std::string& val) {
    expectMatch = val;
  }

  void __set_contentType(const std::string& val) {
    contentType = val;
  }

  void __set_tag(const int32_t val) {
    tag = val;
  }

  bool operator == (const DialOption & rhs) const
  {
    if (!(destUrl == rhs.destUrl))
      return false;
    if (!(testMethod == rhs.testMethod))
      return false;
    if (!(expectCode == rhs.expectCode))
      return false;
    if (!(expectMatch == rhs.expectMatch))
      return false;
    if (!(contentType == rhs.contentType))
      return false;
    if (!(tag == rhs.tag))
      return false;
    return true;
  }
  bool operator != (const DialOption &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialOption & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialOption &a, DialOption &b);

typedef struct _HealthPolicyInfo__isset {
  _HealthPolicyInfo__isset() : name(false), method(false), port(false), freq(false), times(false), passed(false), option(false) {}
  bool name;
  bool method;
  bool port;
  bool freq;
  bool times;
  bool passed;
  bool option;
} _HealthPolicyInfo__isset;

class HealthPolicyInfo {
 public:

  static const char* ascii_fingerprint; // = "06F71DC775194AC33F1C69F647E6A2BA";
  static const uint8_t binary_fingerprint[16]; // = {0x06,0xF7,0x1D,0xC7,0x75,0x19,0x4A,0xC3,0x3F,0x1C,0x69,0xF6,0x47,0xE6,0xA2,0xBA};

  HealthPolicyInfo() : name(), method((DialMethod::type)0), port(0), freq(0), times(0), passed(0) {
  }

  virtual ~HealthPolicyInfo() throw() {}

  std::string name;
  DialMethod::type method;
  int16_t port;
  int32_t freq;
  int32_t times;
  int32_t passed;
  DialOption option;

  _HealthPolicyInfo__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_method(const DialMethod::type val) {
    method = val;
  }

  void __set_port(const int16_t val) {
    port = val;
    __isset.port = true;
  }

  void __set_freq(const int32_t val) {
    freq = val;
  }

  void __set_times(const int32_t val) {
    times = val;
  }

  void __set_passed(const int32_t val) {
    passed = val;
  }

  void __set_option(const DialOption& val) {
    option = val;
  }

  bool operator == (const HealthPolicyInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(method == rhs.method))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    if (!(freq == rhs.freq))
      return false;
    if (!(times == rhs.times))
      return false;
    if (!(passed == rhs.passed))
      return false;
    if (!(option == rhs.option))
      return false;
    return true;
  }
  bool operator != (const HealthPolicyInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HealthPolicyInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(HealthPolicyInfo &a, HealthPolicyInfo &b);

typedef struct _DialRecord__isset {
  _DialRecord__isset() : rid(false), ip(false), ttl(false), priority(false), enabled(false) {}
  bool rid;
  bool ip;
  bool ttl;
  bool priority;
  bool enabled;
} _DialRecord__isset;

class DialRecord {
 public:

  static const char* ascii_fingerprint; // = "2040ECA943D9E6617B68D06B19F667D5";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0x40,0xEC,0xA9,0x43,0xD9,0xE6,0x61,0x7B,0x68,0xD0,0x6B,0x19,0xF6,0x67,0xD5};

  DialRecord() : rid(), ttl(0), priority(0), enabled(0) {
  }

  virtual ~DialRecord() throw() {}

  ObjectId rid;
  IpAddr ip;
  int32_t ttl;
  int32_t priority;
  bool enabled;

  _DialRecord__isset __isset;

  void __set_rid(const ObjectId& val) {
    rid = val;
  }

  void __set_ip(const IpAddr& val) {
    ip = val;
  }

  void __set_ttl(const int32_t val) {
    ttl = val;
  }

  void __set_priority(const int32_t val) {
    priority = val;
  }

  void __set_enabled(const bool val) {
    enabled = val;
  }

  bool operator == (const DialRecord & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(ttl == rhs.ttl))
      return false;
    if (!(priority == rhs.priority))
      return false;
    if (!(enabled == rhs.enabled))
      return false;
    return true;
  }
  bool operator != (const DialRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialRecord &a, DialRecord &b);

typedef struct _DialRecordStatus__isset {
  _DialRecordStatus__isset() : rid(false), status(false), delay(false) {}
  bool rid;
  bool status;
  bool delay;
} _DialRecordStatus__isset;

class DialRecordStatus {
 public:

  static const char* ascii_fingerprint; // = "8AD8F7908FF0D5FB40F4F4BAEA3D0B0A";
  static const uint8_t binary_fingerprint[16]; // = {0x8A,0xD8,0xF7,0x90,0x8F,0xF0,0xD5,0xFB,0x40,0xF4,0xF4,0xBA,0xEA,0x3D,0x0B,0x0A};

  DialRecordStatus() : rid(), status((DialStatus::type)0), delay(0) {
  }

  virtual ~DialRecordStatus() throw() {}

  ObjectId rid;
  DialStatus::type status;
  int64_t delay;

  _DialRecordStatus__isset __isset;

  void __set_rid(const ObjectId& val) {
    rid = val;
  }

  void __set_status(const DialStatus::type val) {
    status = val;
  }

  void __set_delay(const int64_t val) {
    delay = val;
  }

  bool operator == (const DialRecordStatus & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(delay == rhs.delay))
      return false;
    return true;
  }
  bool operator != (const DialRecordStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialRecordStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialRecordStatus &a, DialRecordStatus &b);

typedef struct _DialHealthResult__isset {
  _DialHealthResult__isset() : groupName(false), policyName(false), statusList(false) {}
  bool groupName;
  bool policyName;
  bool statusList;
} _DialHealthResult__isset;

class DialHealthResult {
 public:

  static const char* ascii_fingerprint; // = "3D4EAE4B96E2BF2349FA9E576709D25B";
  static const uint8_t binary_fingerprint[16]; // = {0x3D,0x4E,0xAE,0x4B,0x96,0xE2,0xBF,0x23,0x49,0xFA,0x9E,0x57,0x67,0x09,0xD2,0x5B};

  DialHealthResult() : groupName(), policyName() {
  }

  virtual ~DialHealthResult() throw() {}

  std::string groupName;
  std::string policyName;
  std::vector<DialRecordStatus>  statusList;

  _DialHealthResult__isset __isset;

  void __set_groupName(const std::string& val) {
    groupName = val;
  }

  void __set_policyName(const std::string& val) {
    policyName = val;
  }

  void __set_statusList(const std::vector<DialRecordStatus> & val) {
    statusList = val;
  }

  bool operator == (const DialHealthResult & rhs) const
  {
    if (!(groupName == rhs.groupName))
      return false;
    if (!(policyName == rhs.policyName))
      return false;
    if (!(statusList == rhs.statusList))
      return false;
    return true;
  }
  bool operator != (const DialHealthResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialHealthResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialHealthResult &a, DialHealthResult &b);

typedef struct _DialNginxServer__isset {
  _DialNginxServer__isset() : localURL(false), priority(false) {}
  bool localURL;
  bool priority;
} _DialNginxServer__isset;

class DialNginxServer {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  DialNginxServer() : localURL(), priority(0) {
  }

  virtual ~DialNginxServer() throw() {}

  std::string localURL;
  int32_t priority;

  _DialNginxServer__isset __isset;

  void __set_localURL(const std::string& val) {
    localURL = val;
  }

  void __set_priority(const int32_t val) {
    priority = val;
  }

  bool operator == (const DialNginxServer & rhs) const
  {
    if (!(localURL == rhs.localURL))
      return false;
    if (!(priority == rhs.priority))
      return false;
    return true;
  }
  bool operator != (const DialNginxServer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialNginxServer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialNginxServer &a, DialNginxServer &b);

typedef struct _DialNginxStatus__isset {
  _DialNginxStatus__isset() : server(false), status(false), delay(false) {}
  bool server;
  bool status;
  bool delay;
} _DialNginxStatus__isset;

class DialNginxStatus {
 public:

  static const char* ascii_fingerprint; // = "73F1B3C1E3B5C60C655B5B4BD8AA303B";
  static const uint8_t binary_fingerprint[16]; // = {0x73,0xF1,0xB3,0xC1,0xE3,0xB5,0xC6,0x0C,0x65,0x5B,0x5B,0x4B,0xD8,0xAA,0x30,0x3B};

  DialNginxStatus() : status((DialStatus::type)0), delay(0) {
  }

  virtual ~DialNginxStatus() throw() {}

  DialNginxServer server;
  DialStatus::type status;
  int64_t delay;

  _DialNginxStatus__isset __isset;

  void __set_server(const DialNginxServer& val) {
    server = val;
  }

  void __set_status(const DialStatus::type val) {
    status = val;
  }

  void __set_delay(const int64_t val) {
    delay = val;
  }

  bool operator == (const DialNginxStatus & rhs) const
  {
    if (!(server == rhs.server))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(delay == rhs.delay))
      return false;
    return true;
  }
  bool operator != (const DialNginxStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialNginxStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialNginxStatus &a, DialNginxStatus &b);

typedef struct _DialNginxResult__isset {
  _DialNginxResult__isset() : groupName(false), policyName(false), statusList(false) {}
  bool groupName;
  bool policyName;
  bool statusList;
} _DialNginxResult__isset;

class DialNginxResult {
 public:

  static const char* ascii_fingerprint; // = "6335D96395B8A7E6EB37E0D181972434";
  static const uint8_t binary_fingerprint[16]; // = {0x63,0x35,0xD9,0x63,0x95,0xB8,0xA7,0xE6,0xEB,0x37,0xE0,0xD1,0x81,0x97,0x24,0x34};

  DialNginxResult() : groupName(), policyName() {
  }

  virtual ~DialNginxResult() throw() {}

  std::string groupName;
  std::string policyName;
  std::vector<DialNginxStatus>  statusList;

  _DialNginxResult__isset __isset;

  void __set_groupName(const std::string& val) {
    groupName = val;
  }

  void __set_policyName(const std::string& val) {
    policyName = val;
  }

  void __set_statusList(const std::vector<DialNginxStatus> & val) {
    statusList = val;
  }

  bool operator == (const DialNginxResult & rhs) const
  {
    if (!(groupName == rhs.groupName))
      return false;
    if (!(policyName == rhs.policyName))
      return false;
    if (!(statusList == rhs.statusList))
      return false;
    return true;
  }
  bool operator != (const DialNginxResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialNginxResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialNginxResult &a, DialNginxResult &b);

typedef struct _DialServerStatus__isset {
  _DialServerStatus__isset() : rid(false), ip(false), status(false), delay(false) {}
  bool rid;
  bool ip;
  bool status;
  bool delay;
} _DialServerStatus__isset;

class DialServerStatus {
 public:

  static const char* ascii_fingerprint; // = "AF8E3FB9CBF3978AE2D030441A47DA50";
  static const uint8_t binary_fingerprint[16]; // = {0xAF,0x8E,0x3F,0xB9,0xCB,0xF3,0x97,0x8A,0xE2,0xD0,0x30,0x44,0x1A,0x47,0xDA,0x50};

  DialServerStatus() : rid(), status((DialStatus::type)0), delay(0) {
  }

  virtual ~DialServerStatus() throw() {}

  ObjectId rid;
  IpAddr ip;
  DialStatus::type status;
  int64_t delay;

  _DialServerStatus__isset __isset;

  void __set_rid(const ObjectId& val) {
    rid = val;
  }

  void __set_ip(const IpAddr& val) {
    ip = val;
  }

  void __set_status(const DialStatus::type val) {
    status = val;
  }

  void __set_delay(const int64_t val) {
    delay = val;
  }

  bool operator == (const DialServerStatus & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(delay == rhs.delay))
      return false;
    return true;
  }
  bool operator != (const DialServerStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialServerStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialServerStatus &a, DialServerStatus &b);

typedef struct _DialServerResult__isset {
  _DialServerResult__isset() : status(false), typ(false) {}
  bool status;
  bool typ;
} _DialServerResult__isset;

class DialServerResult {
 public:

  static const char* ascii_fingerprint; // = "9B1BA2DD2DCEEA8FD1297378D74AFCA7";
  static const uint8_t binary_fingerprint[16]; // = {0x9B,0x1B,0xA2,0xDD,0x2D,0xCE,0xEA,0x8F,0xD1,0x29,0x73,0x78,0xD7,0x4A,0xFC,0xA7};

  DialServerResult() : typ((DialServerType::type)0) {
  }

  virtual ~DialServerResult() throw() {}

  DialServerStatus status;
  DialServerType::type typ;

  _DialServerResult__isset __isset;

  void __set_status(const DialServerStatus& val) {
    status = val;
  }

  void __set_typ(const DialServerType::type val) {
    typ = val;
  }

  bool operator == (const DialServerResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(typ == rhs.typ))
      return false;
    return true;
  }
  bool operator != (const DialServerResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialServerResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialServerResult &a, DialServerResult &b);

typedef struct _DcInfo__isset {
  _DcInfo__isset() : id(false), ip(false), PolicyList(false) {}
  bool id;
  bool ip;
  bool PolicyList;
} _DcInfo__isset;

class DcInfo {
 public:

  static const char* ascii_fingerprint; // = "78CEBF88A1820368C93B73ECA52C720A";
  static const uint8_t binary_fingerprint[16]; // = {0x78,0xCE,0xBF,0x88,0xA1,0x82,0x03,0x68,0xC9,0x3B,0x73,0xEC,0xA5,0x2C,0x72,0x0A};

  DcInfo() : id() {
  }

  virtual ~DcInfo() throw() {}

  std::string id;
  IpAddr ip;
  std::vector<std::string>  PolicyList;

  _DcInfo__isset __isset;

  void __set_id(const std::string& val) {
    id = val;
  }

  void __set_ip(const IpAddr& val) {
    ip = val;
  }

  void __set_PolicyList(const std::vector<std::string> & val) {
    PolicyList = val;
  }

  bool operator == (const DcInfo & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(PolicyList == rhs.PolicyList))
      return false;
    return true;
  }
  bool operator != (const DcInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DcInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DcInfo &a, DcInfo &b);

typedef struct _DialDcResult__isset {
  _DialDcResult__isset() : id(false), policy(false), status(false), delay(false) {}
  bool id;
  bool policy;
  bool status;
  bool delay;
} _DialDcResult__isset;

class DialDcResult {
 public:

  static const char* ascii_fingerprint; // = "BDBC9BBEA19355AE3A76B17BCC25C18F";
  static const uint8_t binary_fingerprint[16]; // = {0xBD,0xBC,0x9B,0xBE,0xA1,0x93,0x55,0xAE,0x3A,0x76,0xB1,0x7B,0xCC,0x25,0xC1,0x8F};

  DialDcResult() : id(), policy(), status((DialStatus::type)0), delay(0) {
  }

  virtual ~DialDcResult() throw() {}

  std::string id;
  std::string policy;
  DialStatus::type status;
  int64_t delay;

  _DialDcResult__isset __isset;

  void __set_id(const std::string& val) {
    id = val;
  }

  void __set_policy(const std::string& val) {
    policy = val;
  }

  void __set_status(const DialStatus::type val) {
    status = val;
  }

  void __set_delay(const int64_t val) {
    delay = val;
  }

  bool operator == (const DialDcResult & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(policy == rhs.policy))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(delay == rhs.delay))
      return false;
    return true;
  }
  bool operator != (const DialDcResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialDcResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DialDcResult &a, DialDcResult &b);

typedef struct _SnmpGroupInfo__isset {
  _SnmpGroupInfo__isset() : enable(false), name(false), community(false), user(false), passwd(false), version(false), interval(false), port(false), ip(false), type(false) {}
  bool enable;
  bool name;
  bool community;
  bool user;
  bool passwd;
  bool version;
  bool interval;
  bool port;
  bool ip;
  bool type;
} _SnmpGroupInfo__isset;

class SnmpGroupInfo {
 public:

  static const char* ascii_fingerprint; // = "D3D4594CAB2F905FA95839ACB4FB0CC4";
  static const uint8_t binary_fingerprint[16]; // = {0xD3,0xD4,0x59,0x4C,0xAB,0x2F,0x90,0x5F,0xA9,0x58,0x39,0xAC,0xB4,0xFB,0x0C,0xC4};

  SnmpGroupInfo() : enable(0), name(), community(), user(), passwd(), version(0), interval(0), port(0), type((SnmpDevType::type)0) {
  }

  virtual ~SnmpGroupInfo() throw() {}

  bool enable;
  std::string name;
  std::string community;
  std::string user;
  std::string passwd;
  int32_t version;
  int32_t interval;
  int32_t port;
  IpAddr ip;
  SnmpDevType::type type;

  _SnmpGroupInfo__isset __isset;

  void __set_enable(const bool val) {
    enable = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_community(const std::string& val) {
    community = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_passwd(const std::string& val) {
    passwd = val;
  }

  void __set_version(const int32_t val) {
    version = val;
  }

  void __set_interval(const int32_t val) {
    interval = val;
  }

  void __set_port(const int32_t val) {
    port = val;
  }

  void __set_ip(const IpAddr& val) {
    ip = val;
  }

  void __set_type(const SnmpDevType::type val) {
    type = val;
  }

  bool operator == (const SnmpGroupInfo & rhs) const
  {
    if (!(enable == rhs.enable))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(community == rhs.community))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(passwd == rhs.passwd))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(interval == rhs.interval))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const SnmpGroupInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SnmpGroupInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SnmpGroupInfo &a, SnmpGroupInfo &b);

typedef struct _InterfaceTraffic__isset {
  _InterfaceTraffic__isset() : index(false), inoctets(false), outoctets(false) {}
  bool index;
  bool inoctets;
  bool outoctets;
} _InterfaceTraffic__isset;

class InterfaceTraffic {
 public:

  static const char* ascii_fingerprint; // = "1BC2A204AB4F887721511486B2DFEBC8";
  static const uint8_t binary_fingerprint[16]; // = {0x1B,0xC2,0xA2,0x04,0xAB,0x4F,0x88,0x77,0x21,0x51,0x14,0x86,0xB2,0xDF,0xEB,0xC8};

  InterfaceTraffic() : index(0), inoctets(0), outoctets(0) {
  }

  virtual ~InterfaceTraffic() throw() {}

  int32_t index;
  int64_t inoctets;
  int64_t outoctets;

  _InterfaceTraffic__isset __isset;

  void __set_index(const int32_t val) {
    index = val;
  }

  void __set_inoctets(const int64_t val) {
    inoctets = val;
  }

  void __set_outoctets(const int64_t val) {
    outoctets = val;
  }

  bool operator == (const InterfaceTraffic & rhs) const
  {
    if (!(index == rhs.index))
      return false;
    if (!(inoctets == rhs.inoctets))
      return false;
    if (!(outoctets == rhs.outoctets))
      return false;
    return true;
  }
  bool operator != (const InterfaceTraffic &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InterfaceTraffic & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InterfaceTraffic &a, InterfaceTraffic &b);

typedef struct _IpMac__isset {
  _IpMac__isset() : index(false), ip(false), physaddress(false) {}
  bool index;
  bool ip;
  bool physaddress;
} _IpMac__isset;

class IpMac {
 public:

  static const char* ascii_fingerprint; // = "9B1D74D8FFAD0A13E0712B744A52C094";
  static const uint8_t binary_fingerprint[16]; // = {0x9B,0x1D,0x74,0xD8,0xFF,0xAD,0x0A,0x13,0xE0,0x71,0x2B,0x74,0x4A,0x52,0xC0,0x94};

  IpMac() : index(0), physaddress() {
  }

  virtual ~IpMac() throw() {}

  int32_t index;
  IpAddr ip;
  std::string physaddress;

  _IpMac__isset __isset;

  void __set_index(const int32_t val) {
    index = val;
  }

  void __set_ip(const IpAddr& val) {
    ip = val;
  }

  void __set_physaddress(const std::string& val) {
    physaddress = val;
  }

  bool operator == (const IpMac & rhs) const
  {
    if (!(index == rhs.index))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(physaddress == rhs.physaddress))
      return false;
    return true;
  }
  bool operator != (const IpMac &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IpMac & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(IpMac &a, IpMac &b);

typedef struct _MacTable__isset {
  _MacTable__isset() : macaddress(false), index(false), portname(false) {}
  bool macaddress;
  bool index;
  bool portname;
} _MacTable__isset;

class MacTable {
 public:

  static const char* ascii_fingerprint; // = "70563A0628F75DF9555F4D24690B1E26";
  static const uint8_t binary_fingerprint[16]; // = {0x70,0x56,0x3A,0x06,0x28,0xF7,0x5D,0xF9,0x55,0x5F,0x4D,0x24,0x69,0x0B,0x1E,0x26};

  MacTable() : macaddress(), index(0), portname() {
  }

  virtual ~MacTable() throw() {}

  std::string macaddress;
  int32_t index;
  std::string portname;

  _MacTable__isset __isset;

  void __set_macaddress(const std::string& val) {
    macaddress = val;
  }

  void __set_index(const int32_t val) {
    index = val;
  }

  void __set_portname(const std::string& val) {
    portname = val;
  }

  bool operator == (const MacTable & rhs) const
  {
    if (!(macaddress == rhs.macaddress))
      return false;
    if (!(index == rhs.index))
      return false;
    if (!(portname == rhs.portname))
      return false;
    return true;
  }
  bool operator != (const MacTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MacTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MacTable &a, MacTable &b);

typedef struct _InterfaceInfo__isset {
  _InterfaceInfo__isset() : index(false), descr(false), type(false), status(false), speed(false), mtu(false), physaddress(false) {}
  bool index;
  bool descr;
  bool type;
  bool status;
  bool speed;
  bool mtu;
  bool physaddress;
} _InterfaceInfo__isset;

class InterfaceInfo {
 public:

  static const char* ascii_fingerprint; // = "AE370879A873E96D3FAAE12B6134D7C6";
  static const uint8_t binary_fingerprint[16]; // = {0xAE,0x37,0x08,0x79,0xA8,0x73,0xE9,0x6D,0x3F,0xAA,0xE1,0x2B,0x61,0x34,0xD7,0xC6};

  InterfaceInfo() : index(0), descr(), type(0), status(0), speed(0), mtu(0), physaddress() {
  }

  virtual ~InterfaceInfo() throw() {}

  int32_t index;
  std::string descr;
  int32_t type;
  int32_t status;
  int64_t speed;
  int32_t mtu;
  std::string physaddress;

  _InterfaceInfo__isset __isset;

  void __set_index(const int32_t val) {
    index = val;
  }

  void __set_descr(const std::string& val) {
    descr = val;
  }

  void __set_type(const int32_t val) {
    type = val;
  }

  void __set_status(const int32_t val) {
    status = val;
  }

  void __set_speed(const int64_t val) {
    speed = val;
  }

  void __set_mtu(const int32_t val) {
    mtu = val;
  }

  void __set_physaddress(const std::string& val) {
    physaddress = val;
  }

  bool operator == (const InterfaceInfo & rhs) const
  {
    if (!(index == rhs.index))
      return false;
    if (!(descr == rhs.descr))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(speed == rhs.speed))
      return false;
    if (!(mtu == rhs.mtu))
      return false;
    if (!(physaddress == rhs.physaddress))
      return false;
    return true;
  }
  bool operator != (const InterfaceInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InterfaceInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InterfaceInfo &a, InterfaceInfo &b);

typedef struct _RouteInfo__isset {
  _RouteInfo__isset() : ifindex(false), destination(false), gateway(false), genmask(false), type(false), proto(false) {}
  bool ifindex;
  bool destination;
  bool gateway;
  bool genmask;
  bool type;
  bool proto;
} _RouteInfo__isset;

class RouteInfo {
 public:

  static const char* ascii_fingerprint; // = "0292F2545B3B57ACE50641F34B7452F3";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0x92,0xF2,0x54,0x5B,0x3B,0x57,0xAC,0xE5,0x06,0x41,0xF3,0x4B,0x74,0x52,0xF3};

  RouteInfo() : ifindex(0), type(0), proto(0) {
  }

  virtual ~RouteInfo() throw() {}

  int32_t ifindex;
  IpAddr destination;
  IpAddr gateway;
  IpAddr genmask;
  int32_t type;
  int32_t proto;

  _RouteInfo__isset __isset;

  void __set_ifindex(const int32_t val) {
    ifindex = val;
  }

  void __set_destination(const IpAddr& val) {
    destination = val;
  }

  void __set_gateway(const IpAddr& val) {
    gateway = val;
  }

  void __set_genmask(const IpAddr& val) {
    genmask = val;
  }

  void __set_type(const int32_t val) {
    type = val;
  }

  void __set_proto(const int32_t val) {
    proto = val;
  }

  bool operator == (const RouteInfo & rhs) const
  {
    if (!(ifindex == rhs.ifindex))
      return false;
    if (!(destination == rhs.destination))
      return false;
    if (!(gateway == rhs.gateway))
      return false;
    if (!(genmask == rhs.genmask))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(proto == rhs.proto))
      return false;
    return true;
  }
  bool operator != (const RouteInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RouteInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RouteInfo &a, RouteInfo &b);

typedef struct _SysInfo__isset {
  _SysInfo__isset() : load(false), usercpu(false), syscpu(false), idlecpu(false), totalmem(false), freemem(false), buffer(false), cache(false), availmem(false) {}
  bool load;
  bool usercpu;
  bool syscpu;
  bool idlecpu;
  bool totalmem;
  bool freemem;
  bool buffer;
  bool cache;
  bool availmem;
} _SysInfo__isset;

class SysInfo {
 public:

  static const char* ascii_fingerprint; // = "E559B46C8C264E8A08FC77DF250DF8D1";
  static const uint8_t binary_fingerprint[16]; // = {0xE5,0x59,0xB4,0x6C,0x8C,0x26,0x4E,0x8A,0x08,0xFC,0x77,0xDF,0x25,0x0D,0xF8,0xD1};

  SysInfo() : load(0), usercpu(0), syscpu(0), idlecpu(0), totalmem(0), freemem(0), buffer(0), cache(0), availmem(0) {
  }

  virtual ~SysInfo() throw() {}

  int32_t load;
  int32_t usercpu;
  int32_t syscpu;
  int32_t idlecpu;
  int32_t totalmem;
  int32_t freemem;
  int32_t buffer;
  int32_t cache;
  int32_t availmem;

  _SysInfo__isset __isset;

  void __set_load(const int32_t val) {
    load = val;
  }

  void __set_usercpu(const int32_t val) {
    usercpu = val;
  }

  void __set_syscpu(const int32_t val) {
    syscpu = val;
  }

  void __set_idlecpu(const int32_t val) {
    idlecpu = val;
  }

  void __set_totalmem(const int32_t val) {
    totalmem = val;
  }

  void __set_freemem(const int32_t val) {
    freemem = val;
  }

  void __set_buffer(const int32_t val) {
    buffer = val;
  }

  void __set_cache(const int32_t val) {
    cache = val;
  }

  void __set_availmem(const int32_t val) {
    availmem = val;
  }

  bool operator == (const SysInfo & rhs) const
  {
    if (!(load == rhs.load))
      return false;
    if (!(usercpu == rhs.usercpu))
      return false;
    if (!(syscpu == rhs.syscpu))
      return false;
    if (!(idlecpu == rhs.idlecpu))
      return false;
    if (!(totalmem == rhs.totalmem))
      return false;
    if (!(freemem == rhs.freemem))
      return false;
    if (!(buffer == rhs.buffer))
      return false;
    if (!(cache == rhs.cache))
      return false;
    if (!(availmem == rhs.availmem))
      return false;
    return true;
  }
  bool operator != (const SysInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SysInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SysInfo &a, SysInfo &b);

typedef struct _ProcessInfo__isset {
  _ProcessInfo__isset() : name(false), existflag(false), pid(false), cputime(false), usedmem(false) {}
  bool name;
  bool existflag;
  bool pid;
  bool cputime;
  bool usedmem;
} _ProcessInfo__isset;

class ProcessInfo {
 public:

  static const char* ascii_fingerprint; // = "64188B05601A42A1317799974F112AE1";
  static const uint8_t binary_fingerprint[16]; // = {0x64,0x18,0x8B,0x05,0x60,0x1A,0x42,0xA1,0x31,0x77,0x99,0x97,0x4F,0x11,0x2A,0xE1};

  ProcessInfo() : name(), existflag(0), pid(0), cputime(0), usedmem(0) {
  }

  virtual ~ProcessInfo() throw() {}

  std::string name;
  bool existflag;
  int32_t pid;
  int32_t cputime;
  int32_t usedmem;

  _ProcessInfo__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_existflag(const bool val) {
    existflag = val;
  }

  void __set_pid(const int32_t val) {
    pid = val;
  }

  void __set_cputime(const int32_t val) {
    cputime = val;
  }

  void __set_usedmem(const int32_t val) {
    usedmem = val;
  }

  bool operator == (const ProcessInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(existflag == rhs.existflag))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(cputime == rhs.cputime))
      return false;
    if (!(usedmem == rhs.usedmem))
      return false;
    return true;
  }
  bool operator != (const ProcessInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProcessInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ProcessInfo &a, ProcessInfo &b);

}}}} // namespace

#endif
